# 构建模型

参考自 [link](https://github.com/lyhue1991/eat_pytorch_in_20_days/blob/master/6-1%2C%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B%E7%9A%843%E7%A7%8D%E6%96%B9%E6%B3%95.md)





网络都是属于 nn.Module 的因为在构建的时候都是继承

```python
class Generator(torch.nn.Module):
```



nn.Parameter是继承自torch.Tensor的子类，与torch.Tensor的区别就是nn.Parameter会自动被认为是module的可训练参数，即加入到parameter()这个迭代器中去；而module中非nn.Parameter()的普通tensor是不在parameter中的。



nn.Parameter的对象的requires_grad属性的默认值是True，而torch是false



所以 



Parameter(torch.Tensor(out_features)) 内容是和 torch.Tensor(out_features)





parameters() 迭代器中







所以为什么要注册模型，register_parameter







```
class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()
        self.params = nn.ParameterList([nn.Parameter(torch.randn(10, 10)) for i in range(10)])

    def forward(self, x):
        # ModuleList can act as an iterable, or be indexed using ints
        for i, p in enumerate(self.params):
            x = self.params[i // 2].mm(x) + p.mm(x)
        return x
```







forward 定义了每次执行的 计算步骤



```
import torch.nn as nn
class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.add_module("conv", nn.Conv2d(10, 20, 4))
        self.add_module("conv1", nn.Conv2d(20 ,10, 4))
model = Model()

for sub_module in model.children():
    print(sub_module)
    
# children() 返回当前模型 子模块的迭代器
```





```
import torch.nn as nn
class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.add_module("conv", nn.Conv2d(10, 20, 4))
        self.add_module("conv1", nn.Conv2d(20 ,10, 4))
model = Model()

for module in model.modules():
    print(module)
    
# modules() 返回一个包含 当前模型 所有模块的迭代器。
```



```
for param in model.parameters():
    print(type(param.data), param.size())
    
# parameters 返回一个 包含模型所有参数 的迭代器。
```







#### register_forward_hook(hook)

#### register_buffer(name, tensor)

#### register_parameter(name, param)















### 使用nn.Sequential按层顺序构建模型

```
```

nn.ModuleList作为模型容器

nn.Sequential作为模型容器



> nn.Sequential内部实现了forward函数，因此可以不用写forward函数。而nn.ModuleList则没有实现内部forward函数。







self.net = nn.Sequential(*layers)
